<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><style data-href="/styles.01877a06b072953c14c7.css" id="gatsby-global-css">code[class*=language-],pre[class*=language-]{color:#f8f8f2;background:none;text-shadow:0 1px rgba(0,0,0,.3);font-family:Consolas,Monaco,Andale Mono,Ubuntu Mono,monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background:#272822}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#8292a2}.token.punctuation{color:#f8f8f2}.token.namespace{opacity:.7}.token.constant,.token.deleted,.token.property,.token.symbol,.token.tag{color:#f92672}.token.boolean,.token.number{color:#ae81ff}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#a6e22e}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url,.token.variable{color:#f8f8f2}.token.atrule,.token.attr-value,.token.class-name,.token.function{color:#e6db74}.token.keyword{color:#66d9ef}.token.important,.token.regex{color:#fd971f}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}</style><meta name="generator" content="Gatsby 2.29.0"/><title data-react-helmet="true">How do I choose which SSR strategy to adopt?</title><meta data-react-helmet="true" name="description" content="Server Side Rendering (or SSR) is a big trend. In the React ecosystem, we have plenty of tools that rely on it such as Gatsbyjs or Nextjs…"/><meta data-react-helmet="true" name="twitter:creator" content="@mfrachet"/><meta data-react-helmet="true" name="twitter:card" content="summary"/><meta data-react-helmet="true" property="og:url" content="https://mfrachet.github.io/how-do-i-choose-a-ssr-strategy"/><meta data-react-helmet="true" property="og:type" content="article"/><meta data-react-helmet="true" property="og:title" content="How do I choose which SSR strategy to adopt?"/><meta data-react-helmet="true" property="og:description" content="Server Side Rendering (or SSR) is a big trend. In the React ecosystem, we have plenty of tools that rely on it such as Gatsbyjs or Nextjs…"/><link as="script" rel="preload" href="/webpack-runtime-abe7de642fba5cf7c226.js"/><link as="script" rel="preload" href="/styles-755093da0c07f4b49226.js"/><link as="script" rel="preload" href="/framework-8aba4025690a031b46dc.js"/><link as="script" rel="preload" href="/app-d7dfe1e5681d1d53213b.js"/><link as="script" rel="preload" href="/6eb610abcce4d0fad5f5f9aaf8ec8b37041f2811-639a158acd09c1783239.js"/><link as="script" rel="preload" href="/component---src-templates-blog-template-js-d335fa10a9ac7b6e743d.js"/><link as="fetch" rel="preload" href="/page-data/how-do-i-choose-a-ssr-strategy/page-data.json" crossorigin="anonymous"/><link as="fetch" rel="preload" href="/page-data/app-data.json" crossorigin="anonymous"/></head><body><div id="___gatsby"><div style="outline:none" tabindex="-1" id="gatsby-focus-wrapper"><style data-emotion="css-global ejz20q">html,body{margin:0;padding:0;}body{font-family:-apple-system,system-ui,BlinkMacSystemFont,"Segoe UI",Roboto,"Helvetica Neue",Arial,sans-serif;background:hsl(360, 100%, 100%);font-size:16px;line-height:1.7;}p{margin:0;padding:0;margin-bottom:24px;color:hsl(231, 48%, 22%);font-weight:400;}a{color:unset;font-weight:hsl(231, 48%, 22%);}a:active{opacity:0.5;}ul{margin:0;padding:0;margin-bottom:24px;margin-left:12px;}@media (min-width: 1000px){ul{margin-left:32px;}}.gatsby-highlight{margin-bottom:24px;font-size:0.8rem;}li{margin:0;padding:0;margin-bottom:12px;color:hsl(231, 48%, 22%);font-weight:400;}li:last-of-type{margin-bottom:0;}h1,h2,h3,h4,h5,h6{margin:0;padding:0;font-weight:600;}h1{color:hsl(231, 48%, 48%);margin-bottom:12px;font-size:1.4rem;}h2{margin-bottom:24px;font-size:1.4rem;}h3{margin-bottom:16px;font-size:1.2rem;}@media (min-width: 1000px){h1{font-size:1.7rem;}h2{font-size:1.6rem;}h3{font-size:1.4rem;}}code.language-text{font-size:0.8rem;padding:4px 8px!important;vertical-align:middle!important;background:hsl(231, 48%, 90%)!important;color:hsl(231, 48%, 22%);height:100%;}.token.script.language-javascript,.token.tag,.token.constant{color:#FF6347;}@media (min-width: 1000px){code.language-text{font-size:0.9rem;}}time{display:block;font-size:0.9rem;margin-bottom:24px;}</style><style data-emotion="css 6w1a7a">.css-6w1a7a{position:absolute;height:1px;width:1px;overflow:hidden;clip:rect(1px, 1px, 1px, 1px);white-space:nowrap;}</style><a href="#mfrachet-content" class="css-6w1a7a">Jump to content</a><style data-emotion="css 1lxsp7q">.css-1lxsp7q{-webkit-transition:all .2s;transition:all .2s;z-index:9999;position:fixed;top:0;left:0;width:100%;-webkit-transform:translateX(-100%);-moz-transform:translateX(-100%);-ms-transform:translateX(-100%);transform:translateX(-100%);height:4px;background:hsl(231, 48%, 48%);}</style><div aria-hidden="true" class="css-1lxsp7q"></div><style data-emotion="css 1dpu5wk">.css-1dpu5wk{margin-top:24px;margin-left:24px;margin-right:24px;}@media (min-width: 1000px){.css-1dpu5wk{margin:32px auto;width:65ch;}}</style><div class="css-1dpu5wk"><nav><style data-emotion="css 8qb8m4">.css-8qb8m4{margin-bottom:48px;}</style><div aria-label="Last visited page" role="navigation" class="css-8qb8m4"><style data-emotion="css t3y5ls">.css-t3y5ls{list-style-type:none;margin:0;padding:0;display:-webkit-box;display:-webkit-flex;display:-ms-flexbox;display:flex;-webkit-flex-direction:column;-ms-flex-direction:column;flex-direction:column;}@media (min-width: 1000px){.css-t3y5ls{-webkit-flex-direction:row;-ms-flex-direction:row;flex-direction:row;}}</style><ol class="css-t3y5ls"><style data-emotion="css 1pw74by">.css-1pw74by{margin-bottom:0;}.css-1pw74by:before{content:"";background:hsl(231, 48%, 90%);border:1px solid hsl(231, 48%, 48%);border-radius:50%;}.css-1pw74by [aria-current="page"]{color:hsl(231, 48%, 22%);-webkit-text-decoration:none;text-decoration:none;}.css-1pw74by:last-of-type:before{content:"";background:hsl(231, 48%, 48%);border-radius:50%;}@media (min-width: 1000px){.css-1pw74by:before{content:none;}.css-1pw74by:last-of-type:before{content:none;}}</style><li class="css-1pw74by"><a href="/">Home</a></li><style data-emotion="css 9ek1xx">.css-9ek1xx{margin-bottom:12px;}.css-9ek1xx:before{content:none;}.css-9ek1xx span{display:none;}@media (min-width: 1000px){.css-9ek1xx span{display:block;width:24px;text-align:center;}}</style><li role="separator" aria-hidden="true" class="css-9ek1xx"><span>/</span></li><li class="css-1pw74by"><a href="/posts">Blog posts</a></li><li role="separator" aria-hidden="true" class="css-9ek1xx"><span>/</span></li><style data-emotion="css 2fb6ce">.css-2fb6ce{margin-bottom:0;}.css-2fb6ce:before{content:"";background:hsl(231, 48%, 90%);border:1px solid hsl(231, 48%, 48%);border-radius:50%;}.css-2fb6ce [aria-current="page"]{color:hsl(231, 48%, 48%);-webkit-text-decoration:none;text-decoration:none;}.css-2fb6ce:last-of-type:before{content:"";background:hsl(231, 48%, 48%);border-radius:50%;}@media (min-width: 1000px){.css-2fb6ce:before{content:none;}.css-2fb6ce:last-of-type:before{content:none;}}</style><li class="css-2fb6ce"><a aria-current="page" class="" href="/how-do-i-choose-a-ssr-strategy">How do I choose which SSR strategy to adopt?</a></li></ol></div></nav><div id="mfrachet-content"></div><main><h1>How do I choose which SSR strategy to adopt?</h1><time dateTime="May 25, 2020">May 25, 2020</time><div class="blog-post-content"><p>Server Side Rendering (or SSR) is a big trend. In the React ecosystem, we have plenty of tools that rely on it such as <a href="https://www.gatsbyjs.org/">Gatsbyjs</a> or <a href="https://nextjs.org/">Nextjs</a>.</p>
<p>Before getting further, let's see what happens when a user makes a request on a site that is not built using SSR:</p>
<ul>
<li>The browser makes a request on a specific endpoint</li>
<li>It downloads an empty HTML file that only owns a bunch of <code class="language-text">&lt;script&gt;</code> tags to load some JavaScript code</li>
<li>It resolves / parses / compiles the JavaScript code</li>
<li>It executes the JavaScript code and only then the application can display the content</li>
</ul>
<p>This is how the good old <a href="https://angularjs.org/">Angularjs</a> or <a href="https://jquery.com/">JQuery</a> applications were working. And this is also what happens when we use <a href="https://github.com/facebook/create-react-app">create-react-app</a>.
We say that these applications rely on "Client Side Rendering" (or CSR).</p>
<h2>Why SSR has been invented?</h2>
<p>When building an application using CSR, we <strong>always</strong> have to wait for the JavaScript code to be resolved / parsed / compiled / executed <strong>before</strong> displaying anything on the screen.
The JavaScript application is responsible for filling the HTML file dynamically in the browser.
And this can be problematic because:</p>
<ul>
<li>CSR applications are not optimized for SEO (<a href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web#seo">SEO works, but it's a bit more complicated</a>)</li>
<li>We don't benefit from a good media sharing experience</li>
<li>Displaying the first meaningful content or wait for the application to be interactive can take time when the application is big</li>
</ul>
<p>I remember having worked on Angularjs applications back in 2013 where it could take around 10 seconds to display the first content on the page.</p>
<h2>How does it solve these problems?</h2>
<p>The main idea behind SSR is to generate HTML content and display it to the user the sooner. HTML is easy to understand for browsers, they know how to execute it really fast.</p>
<p>This way, when a user navigates:</p>
<ul>
<li>The browser makes a request on a specific endpoint</li>
<li>It downloads <strong>an already filled HTML content</strong> and can already display it to the user</li>
</ul>
<p>Which is good enough to solve the 3 problems we had:</p>
<div class="gatsby-highlight" data-language="git"><pre class="language-git"><code class="language-git"><span class="token deleted">- CSR applications are not optimized for SEO</span>
<span class="token inserted">+ HTML is optimized for SEO</span>

<span class="token deleted">- We don't benefit from a good media sharing experience</span>
<span class="token inserted">+ Pre-filled HTML owns the necessary meta to have a good sharing experience</span>

<span class="token deleted">- Displaying the first meaningful content or wait for the application to be interactive can take time</span>
<span class="token inserted">+ Displaying HTML content is probably one of the fastest thing a browser can do</span></code></pre></div>
<p>This is the most basic idea behind the term SSR and with this in mind, we can create complex and powerful mechanisms (non-exhaustive list):</p>
<h3>Runtime SSR</h3>
<ul>
<li>Start a NodeJS server</li>
<li>When a request is made, render static HTML content (string format)</li>
<li>When the browser is ready, start a client side application for interactivity</li>
<li>Tools: <a href="https://nextjs.org/">Nextjs</a></li>
</ul>
<p>The first way to rely on SSR we've seen in the React community. Can be complex to put in practice and costs money:
one or several NodeJS servers have to be running in production to manage the requests.</p>
<h3>Static Generation</h3>
<ul>
<li>At build time (when running <code class="language-text">npm run build</code> or <code class="language-text">yarn build</code>)</li>
<li>Generate as many <strong>HTML files (.html)</strong> as necessary</li>
<li>When a request is made, render the associated .html file</li>
<li>Tools: <a href="https://docusaurus.io/">Docusaurus</a>, <a href="https://github.com/11ty/eleventy/">11ty</a></li>
<li>Performance case study by <a href="https://medium.com/dev-channel/a-netflix-web-performance-case-study-c0bcde26a9d9">Netflix on the landing page</a></li>
</ul>
<p>Common in the documentation / blogging area where interactivity is not required. Tools take something like Markdown content in input and create
the associated .html files as output. Not too complex to use in practice, not expensive thanks to CDN hostings.</p>
<h3>Build time SSR / Pre-rendering</h3>
<ul>
<li>At build time (when running <code class="language-text">npm run build</code> or <code class="language-text">yarn build</code>)</li>
<li>Generate as many <strong>HTML files (.html)</strong> as necessary</li>
<li>When a request is made, render the associated .html file</li>
<li>When the browser is ready, start a client side application for interactivity</li>
<li>Tools: <a href="https://www.gatsbyjs.org/">Gatsby</a>, <a href="https://nextjs.org/">Nextjs</a></li>
</ul>
<p>Probably my favorite of all the listed solutions. Very scalable, highly interactive, not too complex to use in practice and not expensive thanks to CDN hostings.</p>
<h2>How to choose?</h2>
<p>This is where it gets tricky.</p>
<p><strong>Choosing a strategy is not about finding the best solution</strong>. It's about evaluating trade offs and taking the
technic that provides <strong>the most benefit in our context</strong> than it provides drawbacks.</p>
<p>Also, I'm feeling that the last few years we tend to use SSR almost everywhere and as much as we can.
While it's an amazing tool that helps in many situations, I think
we should keep in mind that <strong>it's just a tool</strong> - not a silver bullet solution. If we don't face the problems it's supposed to solve, I'm not convinced we should introduce it in a project.
<strong>Remember that introducing SSR is not free</strong>, it has a technical cost and a potential infrastructure cost.</p>
<p>Finally we don't have to choose a single way of building an app: we can cross the ideas and create a system that provides the best user experience in our scenario.</p>
<p>The following diagram is one of the mental representations I'm using to determine when I would consider using a technic over another one in a given situation. <strong>It's not a source of truth at all</strong>.</p>
<p><span
      class="gatsby-resp-image-wrapper"
      style="position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; "
    >
      <a
    class="gatsby-resp-image-link"
    href="/static/dc4089078ea1f5573fa5a69ed965fcee/49d9b/ssr.png"
    style="display: block"
    target="_blank"
    rel="noopener"
  >
    <span
    class="gatsby-resp-image-background-image"
    style="padding-bottom: 70.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAt0lEQVQ4y62T2w6DIBBEEQSt1VYLvfz/l3ZJDglRHvAyyUlWTYbdWVSqLC08hF5doEawghNawZwx60FjrDB2Rw2fwkRnGmKHb+EreGERxj2mmpEtxlF3zAL1oWyj4e1Mfim3RHzusjp1Xm0WuxkYJ3U3YWqpQ82CPKH/CFuvrlBSx4Lc6v1GH5jpzhSyHPnWYuz3LsZxwAhLNqrO7mu1DBlaalMYs+H37NSFmhn/dZX5wjIDN2T4AzNJA7pk2BbOAAAAAElFTkSuQmCC'); background-size: cover; display: block;"
  ></span>
  <img
        class="gatsby-resp-image-image"
        alt="Mental SSR path to make a choice"
        title="Mental SSR path to make a choice"
        src="/static/dc4089078ea1f5573fa5a69ed965fcee/37523/ssr.png"
        srcset="/static/dc4089078ea1f5573fa5a69ed965fcee/e9ff0/ssr.png 180w,
/static/dc4089078ea1f5573fa5a69ed965fcee/f21e7/ssr.png 360w,
/static/dc4089078ea1f5573fa5a69ed965fcee/37523/ssr.png 720w,
/static/dc4089078ea1f5573fa5a69ed965fcee/302a4/ssr.png 1080w,
/static/dc4089078ea1f5573fa5a69ed965fcee/07a9c/ssr.png 1440w,
/static/dc4089078ea1f5573fa5a69ed965fcee/49d9b/ssr.png 4578w"
        sizes="(max-width: 720px) 100vw, 720px"
        style="width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;"
        loading="lazy"
      />
  </a>
    </span></p></div></main></div></div><div id="gatsby-announcer" style="position:absolute;top:0;width:1px;height:1px;padding:0;overflow:hidden;clip:rect(0, 0, 0, 0);white-space:nowrap;border:0" aria-live="assertive" aria-atomic="true"></div></div><script id="gatsby-script-loader">/*<![CDATA[*/window.pagePath="/how-do-i-choose-a-ssr-strategy";/*]]>*/</script><script id="gatsby-chunk-mapping">/*<![CDATA[*/window.___chunkMapping={"polyfill":["/polyfill-9c732dc6dbb77c35d9a2.js"],"app":["/app-d7dfe1e5681d1d53213b.js"],"component---cache-caches-gatsby-plugin-offline-app-shell-js":["/component---cache-caches-gatsby-plugin-offline-app-shell-js-16703ee5599528db9f93.js"],"component---src-pages-404-tsx":["/component---src-pages-404-tsx-b34199194a3fd2ce0089.js"],"component---src-pages-index-tsx":["/component---src-pages-index-tsx-1bab9e2907faa58bc6ba.js"],"component---src-pages-posts-tsx":["/component---src-pages-posts-tsx-1877c2d8118c2caa3109.js"],"component---src-templates-blog-template-js":["/component---src-templates-blog-template-js-d335fa10a9ac7b6e743d.js"]};/*]]>*/</script><script src="/polyfill-9c732dc6dbb77c35d9a2.js" nomodule=""></script><script src="/component---src-templates-blog-template-js-d335fa10a9ac7b6e743d.js" async=""></script><script src="/6eb610abcce4d0fad5f5f9aaf8ec8b37041f2811-639a158acd09c1783239.js" async=""></script><script src="/app-d7dfe1e5681d1d53213b.js" async=""></script><script src="/framework-8aba4025690a031b46dc.js" async=""></script><script src="/styles-755093da0c07f4b49226.js" async=""></script><script src="/webpack-runtime-abe7de642fba5cf7c226.js" async=""></script></body></html>