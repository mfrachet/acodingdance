<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Choosing a rendering strategy | On my way to product engineering</title>

    <meta name="author" content="Marvin Frachet">
    <meta name="description" content="This post is about describing a set of React Rendering Strategies and give hints on which one to pick and when.">
    <meta name="keywords" content="ssr, ssg, server side rendering, static site generation, crs, client side rendering, react, nextjs, gatsby">

    

    <style>
      a,abbr,acronym,address,applet,article,aside,audio,b,big,blockquote,body,canvas,caption,center,cite,code,dd,del,details,dfn,div,dl,dt,em,embed,fieldset,figcaption,figure,footer,form,h1,h2,h3,h4,h5,h6,header,hgroup,html,i,iframe,img,ins,kbd,label,legend,li,mark,menu,nav,object,ol,output,p,pre,q,ruby,s,samp,section,small,span,strike,strong,sub,summary,sup,table,tbody,td,tfoot,th,thead,time,tr,tt,u,ul,var,video{margin:0;padding:0;border:0;font-size:100%;font:inherit;vertical-align:baseline}article,aside,details,figcaption,figure,footer,header,hgroup,menu,nav,section{display:block}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:after,blockquote:before,q:after,q:before{content:"";content:none}table{border-collapse:collapse;border-spacing:0}*,:after,:before{box-sizing:border-box}body,html{height:100%}body{font-family:-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Oxygen,Ubuntu,Cantarell,"Open Sans","Helvetica Neue",sans-serif}em{font-style:italic}strong{font-weight:700}.theme{--fs-0:0.7rem;--fs-1:0.9rem;--fs-2:1rem;--fs-3:1.2rem;--fs-4:1.3rem;--fs-5:1.4rem;--fs-6:1.6rem;--fs-7:1.8rem;--fs-8:2.2rem;--fs-9:2.6rem;--fs-10:3rem;--s-0:4px;--s-1:8px;--s-2:12px;--s-3:16px;--s-4:24px;--s-5:32px;--s-6:48px;--s-7:64px;--s-8:96px;--fw-text:400;--fw-heading:600;--fw-extraBold:800}.light{--primary-color:hsl(231deg, 48%, 48%);--primary-color-lighter:hsl(231deg, 48%, 96%);--secondary-color:hsl(340deg, 82%, 52%);--text-color:#272727;--bg-color:#fff;min-height:100%;background:var(--bg-color);color:var(--text-color)}.light :focus-visible{outline:3px dashed var(--secondary-color);outline-offset:3px}.light :focus:not(:focus-visible){outline:0;outline:1px dashed var(--primary-color)}.theme h1{font-size:var(--fs-10);font-weight:var(--fw-extraBold);line-height:1.4;margin-top:var(--s-4);margin-bottom:var(--s-4);background-image:linear-gradient(90deg,var(--primary-color),var(--secondary-color));background-clip:text;-webkit-background-clip:text;-webkit-text-fill-color:transparent;-moz-background-clip:text;-moz-text-fill-color:transparent}.theme h2{font-size:var(--fs-8);line-height:1.4;font-weight:var(--fw-heading);margin-bottom:var(--s-2);margin-top:var(--s-5)}.theme h2+h3{margin-top:var(--s-3)}.theme h3{font-size:var(--fs-6);line-height:1.4;margin-bottom:var(--s-2);margin-top:var(--s-5)}.theme h4{font-size:var(--fs-5);line-height:1.4;margin-bottom:var(--s-1);margin-top:var(--s-2)}.theme pre{margin-bottom:var(--s-4)}.theme p{font-size:var(--fs-2);line-height:1.8;margin-bottom:var(--s-4)}.theme ul{padding:0 var(--s-2);margin-bottom:var(--s-3);margin-left:var(--s-2)}.theme ul li{padding:var(--s-1);line-height:1.8;position:relative;font-size:var(--fs-2)}.theme ul li:before{content:"";position:absolute;width:8px;height:8px;background:var(--secondary-color);left:calc(var(--s-2) * -1);top:18px}.theme time{display:inline-block;font-size:var(--fs-0);font-style:italic}.post{margin-bottom:var(--s-5)}.theme.light a{color:var(--primary-color);padding-bottom:1px;text-decoration:none;border-bottom:1px solid var(--primary-color)}.theme .wrapper{max-width:70ch;margin:0 auto;padding:var(--s-3)}h2.post-title{margin-top:var(--s-1);font-size:var(--fs-6)}.theme.light p>code{color:var(--primary-color);background:var(--primary-color-lighter);padding:var(--s-0);border-radius:4px;font-size:var(--fs-1)}.theme.light li>code{color:var(--primary-color);background:var(--primary-color-lighter);padding:var(--s-0);border-radius:4px;font-size:var(--fs-1)}.theme nav.main-navigation ul{display:flex;align-items:center;margin:0;padding:0}.theme nav.main-navigation ul li a{font-size:var(--fs-2)}.theme nav.main-navigation ul li:before{content:unset}.theme nav.main-navigation li{margin-right:var(--s-2)}nav.main-navigation li:last-of-type{margin-right:0}#skip-to-content{border:0;clip:rect(0 0 0 0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}#skip-to-content:focus{border:unset;clip:unset;height:unset;margin:unset;overflow:unset;padding:unset;position:absolute;width:unset;top:var(--s-2);left:var(--s-4);padding:var(--s-2);background:var(--primary-color);color:var(--bg-color);border-radius:4px}iframe,img,video{max-height:100%;max-width:100%;margin:8px 0}code[class*=language-],pre[class*=language-]{color:#f8f8f2;background:0 0;text-shadow:0 1px rgba(0,0,0,.3);font-family:Consolas,Monaco,"Andale Mono","Ubuntu Mono",monospace;font-size:1em;text-align:left;white-space:pre;word-spacing:normal;word-break:normal;word-wrap:normal;line-height:1.5;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-hyphens:none;-moz-hyphens:none;-ms-hyphens:none;hyphens:none}pre[class*=language-]{padding:1em;margin:.5em 0;overflow:auto;border-radius:.3em}:not(pre)>code[class*=language-],pre[class*=language-]{background:#272822}:not(pre)>code[class*=language-]{padding:.1em;border-radius:.3em;white-space:normal}.token.cdata,.token.comment,.token.doctype,.token.prolog{color:#708090}.token.punctuation{color:#f8f8f2}.token.namespace{opacity:.7}.token.constant,.token.deleted,.token.property,.token.symbol,.token.tag{color:#f92672}.token.boolean,.token.number{color:#ae81ff}.token.attr-name,.token.builtin,.token.char,.token.inserted,.token.selector,.token.string{color:#a6e22e}.language-css .token.string,.style .token.string,.token.entity,.token.operator,.token.url,.token.variable{color:#f8f8f2}.token.atrule,.token.attr-value,.token.class-name,.token.function{color:#e6db74}.token.keyword{color:#66d9ef}.token.important,.token.regex{color:#fd971f}.token.bold,.token.important{font-weight:700}.token.italic{font-style:italic}.token.entity{cursor:help}
    </style>
  </head>
  <body>
    <div class="theme light">
      <a href="#main-content" id="skip-to-content">Skip to main content</a>

      <div class="wrapper">
        <nav class="main-navigation">
    <ul>
        <li>
            <a href="/">Home</a>
        </li>
        <li>
            <a href="/blog">Blog posts</a>
        </li>
        <li>
            <a href="https://github.com/mfrachet"  target="_blank" rel="noopener noreferrer">Github</a>
        </li>
        <li>
            <a href="https://www.linkedin.com/feed/"  target="_blank" rel="noopener noreferrer">LinkedIn</a>
        </li>
    </ul>
</nav>

        <main id="main-content">
          <h1>Choosing a rendering strategy</h1>

          <p>This post is about describing a set of React Rendering Strategies and give hints on which one to pick and when.</p>
<p>In the beginning, when we had to write frontend applications, everything was happening inside the browser. To retrieve the content of a page, here's what happened:</p>
<ul>
<li>The browser requested a specific endpoint</li>
<li>It downloaded an empty HTML file that only contains a bunch of <code>&lt;script&gt;</code> tags</li>
<li>It resolved/parsed/compiled the JavaScript code</li>
<li>It executed the JavaScript code</li>
<li>The application could now be displayed</li>
</ul>
<p>This is how <a href="https://angularjs.org/">Angularjs</a> applications were working back in the days. And this is also how <a href="https://github.com/facebook/create-react-app">create-react-app</a> works.</p>
<h2>Why wasn't it enough?</h2>
<p>When building applications that way, <strong>we always have to wait</strong> for the JavaScript code to be resolved/parsed/compiled/executed <strong>before displaying anything</strong> on the screen since
the JavaScript application is responsible for displaying the page content.</p>
<aside>
  <p>
    This Rendering Strategy is called
    <a href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web#csr">
      Client Side Rendering(CSR)
    </a>
    and means that everything runs on the client: in this situation,
    <strong>the browser</strong>.
  </p>
</aside>
<p>Running everything on the client-side has drawbacks:</p>
<ul>
<li>CSR applications are not optimized for SEO (<a href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web#seo">SEO works, but it's a bit more complicated</a>)</li>
<li>We don't benefit from a good media sharing experience</li>
<li>Displaying the first meaningful content or wait for the application to be interactive can take time when the application is big</li>
</ul>
<h2>How to solve these problems?</h2>
<p>The main way to solve this problem is to shift the first page rendering to the server.</p>
<p>Instead of requesting an empty HTML file and leave the responsibility to display the content to the browser using JavaScript, we can request an endpoint that will return <strong>an already full page containing all the HTML markup</strong> with the content inside.</p>
<pre class="language-git"><code class="language-git"><span class="token deleted">- CSR applications are not optimized for SEO</span><br><span class="token inserted">+ HTML is optimized for SEO</span><br><br><span class="token deleted">- We don't benefit from a good media sharing experience</span><br><span class="token inserted">+ Pre-filled HTML owns the necessary meta to have a good sharing experience</span><br><br><span class="token deleted">- Displaying the first meaningful content or wait for the application to be interactive can take time</span><br><span class="token inserted">+ Displaying HTML content is probably one of the fastest things a browser can do</span></code></pre>
<p>This is the most basic way to think about <a href="https://developers.google.com/web/updates/2019/02/rendering-on-the-web#server-rendering">Server Side Rendering (SSR)</a> where the server is now responsible for providing the page content.</p>
<p>Since this idea is very broad, it opened doors to multiple Rendering Strategies relying on different mechanisms to achieve these goals.</p>
<h3>Runtime SSR</h3>
<ul>
<li>Start a NodeJS server</li>
<li>When a request is made, render static HTML content</li>
<li>When the browser is ready, start a client-side application for interactivity</li>
</ul>
<p>It's a very convenient approach since it allows to render <strong>every page</strong> on the server. Even the ones that protected using authentication. This capability is not possible using other rendering strategies.</p>
<p>It's also worth mentioning that when building Runtime SSR by hand, without using dedicated tools, it can be complex to put into practice. Running runtime SSR at scale might also have a cost since one or multiple NodeJS servers have to be running to be responsive to the traffic.</p>
<p>However, tools like <a href="https://nextjs.org/docs/basic-features/pages#server-side-rendering">Nextjs</a> have made this a breath to work with this approach.</p>
<h3>Static Generation (without JavaScript)</h3>
<ul>
<li>At build time (when running the equivalence of <code>npm run build</code>)</li>
<li>Generate as many <strong>HTML files (.html)</strong> as necessary</li>
<li>When a request is made, render the associated .html file</li>
</ul>
<p>This approach is common in the documentation/blogging area where interactivity may not be a requirement but fast page loading is important. It's an approach that exists for years now thanks to tools like
<a href="https://github.com/jekyll/jekyll">Jekyll</a> or <a href="https://github.com/gohugoio/hugo">Hugo</a> in other ecosystems. In the JavaScript one, it's worth mentioning <a href="https://docusaurus.io/">Docusaurus</a>, <a href="https://github.com/11ty/eleventy/">11ty</a>, or <a href="https://github.com/vuejs/vuepress">VuePress</a>.</p>
<h3>Build time SSR / Pre-rendering</h3>
<p><em>The naming might not be perfect. We often refer to this technic as SSG, but since it's a little bit different, I prefer to give it a dedicated name for the sake of clarity.</em></p>
<ul>
<li>At build time (when running <code>npm run build</code> or <code>yarn build</code>)</li>
<li>Generate as many <strong>HTML files (.html)</strong> as necessary</li>
<li>When a request is made, render the associated .html file</li>
<li>When the browser is ready, start a client-side application for interactivity</li>
</ul>
<p>This approach mixes SSG and CSR to create scalable and interactive experiences.</p>
<p>With this approach, people from certain teams can contribute public pages that are very fast to load, but it does not prevent having richer experiences such as dashboards for authenticated users, etc. that SSG (strictly speaking) does not provide.</p>
<p>This approach is considered very scalable, highly interactive, not too complex to use in practice, and not expensive thanks to CDN hostings.</p>
<p>Tools: <a href="https://www.gatsbyjs.org/">Gatsby</a>, <a href="https://nextjs.org/">Nextjs</a></p>
<h2>How to choose?</h2>
<p>The great news is that <strong>you don't have to</strong>.</p>
<p><strong>All these technics can be used in the same project</strong> but serve different purposes depending on the use cases. <a href="https://nextjs.org/docs">Nextjs</a> folks, in particular, have made huge efforts to allow for mixing the strategies depending on their users' needs.</p>
<p><strong>However</strong>, sometimes we have very precise use cases and we want a tool that solves that specific problem.</p>
<p>If you're in one of these situations, the following diagram is one of the mental representations I'm using to determine when I would consider using a technic over another one in a given situation. <strong>Note that this is a personal thing</strong>.</p>
<p><img src="./ssr.png" alt="Mental SSR path to make a choice"></p>

        </main>
      </div>
    </div>
  </body>
</html>