---
title: "How do I decide which SSR strategy to adopt?"
date: 2020-05-20
slug: "/how-do-i-decide-ssr-strategy"
---

Server Side Rendering (or SSR) is a really big trend. In the React ecosystem, we have plenty of tools that rely on this like [Gatsbyjs](https://www.gatsbyjs.org/) or [Nextjs](https://nextjs.org/).

Before getting further about SSR, let's try to see what happens when a user makes a request on a site that is NOT using SSR:

- The browser makes a request on a specific URI
- It downloads an empty HTML file that only has a bunch of `<script>` tags inside to load some JS code
- It resolves / parses / compiles the JS code
- It executes the JS code and that's only then the application is ready and displays content to the user

This is how the good old [Angularjs](https://angularjs.org/) or [JQuery](https://jquery.com/) applications were working. And this is also what happens when we use [create-react-app](https://github.com/facebook/create-react-app).
We say that these applications rely on "Client Side Rendering" (or CSR).

#### Why SSR has been invented?

When building an application using CSR, we **always** have to wait for the JS code to be resolved / parsed / compiled / executed **before** having anything displayed on the screen.
And this can be problematic because:

- CSR apps are not optimized for SEO (SEO works, but it takes longer)
- We don't benefit from a good media sharing experience
- It can take time to boot a huge JS application in the browser

_I remember having worked on an Angularjs application in 2013 where it took around 7 seconds to display the first content on the page._

#### How does it solve these problems?

The main idea behind SSR is to generate HTML content and make it available the sooner to the end user.

This way, when a user makes a request:

- The browser makes a request on a specific URI
- It downloads **an already filled HTML file** and can already display it to the user

This is the most basic idea behind the term SSR. Starting back from this, we can create really complex mechanisms.


**Runtime SSR**

- Start a nodejs server
- When a request is made, render static HTML content (string format)
- Start a client side application in the browser for interactivity
- Used by [Nextjs](https://nextjs.org/)
- First way of SSR we've seen in the React ecosystem

**Static Generation**

- At build time (when running `npm run build` or `yarn build`)
- Generate as many **HTML files (.html)** as necessary
- When a request is made, render the associated .html file
- Used by [Docusaurus](https://docusaurus.io/)

**Build time SSR / Pre-rendering**

- At build time (when running `npm run build` or `yarn build`)
- Generate as many **HTML files (.html)** as necessary
- When a request is made, render the associated .html file
- Start a lightweight client side application in the browser for interactivity
- Used by [Gatsby](https://www.gatsbyjs.org/)

None of the previous solutions are mutually exclusive. It's up to you to pick one or to combine multiple for your project.

And this is where it gets tricky.

#### How to choose?

The following diagram is one of the mental representations I'm using when I build a new application that potentially needs SSR. Weirdly, everything starts with: "Do we have public pages?"

![Mental SSR path to make a choice](./ssr.png)