---
title: "How do I decide which SSR strategy to adopt?"
date: 2020-05-20
slug: "/how-do-i-decide-ssr-strategy"
---

Server Side Rendering (or SSR) is a really big trend. In the React ecosystem, we have plenty of tools that rely on this like [Gatsbyjs](https://www.gatsbyjs.org/) or [Nextjs](https://nextjs.org/).

Before getting further about SSR, let's try to see what happens when a user makes a request on a site that is NOT using SSR:

- The browser makes a request on a specific URI
- It downloads an empty HTML file that only has a bunch of `<script>` tags inside to load some JS code
- It resolves / parses / compiles the JS code
- It executes the JS code and that's only then the application is ready and displays content to the user

This is how the good old [Angularjs](https://angularjs.org/) or [JQuery](https://jquery.com/) applications were working. And this is also what happens when we use [create-react-app](https://github.com/facebook/create-react-app).
We say that these applications rely on "Client Side Rendering" (or CSR).

#### Why SSR has been invented?

When building an application using CSR, we **always** have to wait for the JS code to be resolved / parsed / compiled / executed **before** having anything displayed on the screen.
And this can be problematic because:

- CSR apps are not optimized for SEO (SEO works, but it takes longer)
- We don't benefit from a good media sharing experience
- It can take time to boot a huge JS application in the browser

_I remember having worked on an Angularjs application in 2013 where it took around 7 seconds to display the first content on the page._

#### How does it solve these problems?

The main idea behind SSR is to generate HTML content and make it available the sooner to the end user.

This way, when a user makes a request:

- The browser makes a request on a specific URI
- It downloads **an already filled HTML file** and can already display it to the user

This is the most basic idea behind the term SSR. Starting back from this, we can create really complex mechanisms.


We can, for example, start a nodejs server that will render HTML content every time a request is made, and when the HTML is displayed to the user, it can start a JavaScript
application for a high interactivity experience. This is what [Nextjs](https://nextjs.org/) does and this is the first way of SSR we've seen in the React ecosystem, we can call it _runtime SSR_.

We can also rely on SSR at build time (the moment you run `npm run build` or `yarn build` to generate your app). In that case, the idea is to generate as many filled HTML pages as needed (like real `.html` files). Once it's done, when a user makes a request, it directly access the pre-generated HTML content, which is super fast! This is how [Docusaurus](https://docusaurus.io/) works.

If you combine the last point and tells the HTML pages to start lightweight JavaScript applications, you end up in a system that looks like [Gatsby](https://www.gatsbyjs.org/), without the plugins.

None of the previous solutions are mutually exclusive. It's up to you to rely on one or the others (maybe mixing them?) depending on your use case.

And this is where it gets tricky and where the title of this post comes from.

#### How do I decide which SSR strategy to adopt?

The following diagram is one of the mental representations I'm using when I build a new application that potentially needs SSR. Weirdly, everything starts with: "Do we have public pages?"

![Mental SSR path to make a choice](./ssr.png)