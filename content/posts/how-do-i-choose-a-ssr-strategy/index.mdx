---
title: "How do I choose which SSR strategy to adopt?"
date: 2020-05-20
slug: "/how-do-i-choose-a-ssr-strategy"
---

Server Side Rendering (or SSR) is a really big trend. In the React ecosystem, we have plenty of tools that rely on it such as [Gatsbyjs](https://www.gatsbyjs.org/) or [Nextjs](https://nextjs.org/).

Before getting further, let's see what happens when a user makes a request on a site that is not built using SSR:

- The browser makes a request on a specific endpoint
- It downloads an empty HTML file that only owns a bunch of `<script>` tags to load some JS code
- It resolves / parses / compiles the JS code
- It executes the JS code and only then the application can display the content

This is how the good old [Angularjs](https://angularjs.org/) or [JQuery](https://jquery.com/) applications were working. And this is also what happens when we use [create-react-app](https://github.com/facebook/create-react-app).
We say that these applications rely on "Client Side Rendering" (or CSR).

#### Why SSR has been invented?

When building an application using CSR, we **always** have to wait for the JS code to be resolved / parsed / compiled / executed **before** displaying anything on the screen.
And this can be problematic because:

- CSR applications are not optimized for SEO ([SEO works, but it's a bit more complicated](https://developers.google.com/web/updates/2019/02/rendering-on-the-web#seo))
- We don't benefit from a good media sharing experience
- It can take time to boot a big JS application in the browser

_I remember having worked on an Angularjs application in 2013 where it took around 10 seconds to display the first content on the page._

#### How does it solve these problems?

The main idea behind SSR is to generate HTML content and display it to the user the sooner. HTML is easy to understand for browsers, they know how to execute it really fast.

This way, when a user navigates:

- The browser makes a request on a specific endpoint
- It downloads **an already filled HTML content** and can already display it to the user

This is the most basic idea behind the term SSR. With this in mind, we can create really complex mechanisms.


**Runtime SSR**

- Start a nodejs server
- When a request is made, render static HTML content (string format)
- Start a client side application in the browser for interactivity
- Used by [Nextjs](https://nextjs.org/)
- First way of SSR we've seen in the React ecosystem

**Static Generation**

- At build time (when running `npm run build` or `yarn build`)
- Generate as many **HTML files (.html)** as necessary
- When a request is made, render the associated .html file
- Used by [Docusaurus](https://docusaurus.io/)

**Build time SSR / Pre-rendering**

- At build time (when running `npm run build` or `yarn build`)
- Generate as many **HTML files (.html)** as necessary
- When a request is made, render the associated .html file
- Start a lightweight client side application in the browser for interactivity
- Used by [Gatsby](https://www.gatsbyjs.org/)


And this is where it gets tricky.

#### How to choose?

Stepping back from the last few years, I'm feeling that we tend to use SSR almost everywhere and as much as we can.
While it's an amazing tool that helps in many situations, I think
we should keep in mind that **it's just a tool** - not a miracle solution. If we don't face the problems it's supposed to solve, I'm not convinced we should introduce it in a project.

I'm personally in favor of CSR since it's the reason why I embraced frontend development at first: create highly interactive user experiences _in the browser_.

But loving CSR doesn't mean I don't have to deal with SSR. The following diagram is one of my mental representations on when I would introduce SSR and using which strategy.
It's based on my mind and is opinionated, as all this blog:

![Mental SSR path to make a choice](./ssr.png)

